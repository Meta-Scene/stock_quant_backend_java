<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.example.stock.mapper.StockDataMapper">
    <!-- 
        根据日期范围查询股票数据 
        使用CTE(Common Table Expressions)实现复杂查询：
        1. stock_codes: 获取指定日期的股票代码，支持分页
        2. prev_dates: 获取指定日期前的交易日(最多41天)
        3. next_dates: 获取指定日期后的交易日(最多41天)
        4. date_range: 确定最终的日期范围
        最后连接这些临时表获取完整的股票数据
    -->
    <select id="findByDateRange" resultType="com.example.stock.entity.StockData">
        WITH stock_codes AS (
            SELECT DISTINCT a.ts_code
            FROM all_stocks_days a
            WHERE a.trade_date = #{startDate}
            <if test="tsCode != null">
                AND a.ts_code = #{tsCode}
            </if>
            ORDER BY a.ts_code
            LIMIT #{pageSize} OFFSET #{offset}
        ),
        prev_dates AS (
            SELECT DISTINCT trade_date
            FROM all_stocks_days
            WHERE trade_date &lt;= #{startDate}
            ORDER BY trade_date DESC
            LIMIT 41
        ),
        next_dates AS (
            SELECT DISTINCT trade_date
            FROM all_stocks_days
            WHERE trade_date &gt;= #{startDate}
            ORDER BY trade_date ASC
            LIMIT 41
        ),
        date_range AS (
            SELECT 
                (SELECT MIN(trade_date) FROM prev_dates) AS start_date,
                (SELECT MAX(trade_date) FROM next_dates) AS end_date
        )
        SELECT a.id, a.ts_code, a.trade_date, a.open, a.high, a.low, a.close, a.pct_chg, a.vol, 
               a.amount, a.state,
               COALESCE(NULLIF(a.ma120, 'NaN'), NULL) as ma120, 
               COALESCE(NULLIF(a.ma250, 'NaN'), NULL) as ma250,
               a.name
        FROM all_stocks_days a
        JOIN stock_codes s ON a.ts_code = s.ts_code
        JOIN date_range d ON a.trade_date BETWEEN d.start_date AND d.end_date
        ORDER BY a.ts_code, a.trade_date ASC
    </select>

    <!-- 
        查询涨停股票数据 
        涨停标准为涨幅大于等于6.0%
        使用CTE结构:
        1. limit_up_stocks: 筛选指定日期涨幅>=6.0%的股票
        2. prev_dates和next_dates: 获取前后各41个交易日
        3. date_range: 确定日期范围
        最终返回符合条件股票在日期范围内的所有交易数据
    -->
    <select id="findLimitUp" resultType="com.example.stock.entity.StockData">
        WITH limit_up_stocks AS (
            SELECT DISTINCT a.ts_code, a.pct_chg
            FROM all_stocks_days a
            <where>
                <if test="tsCode != null">
                    a.ts_code = #{tsCode} AND
                </if>
                a.trade_date = #{startDate} AND a.pct_chg &gt;= 6.0
            </where>
            ORDER BY a.pct_chg DESC
            LIMIT #{pageSize} OFFSET #{offset}
        ),
        prev_dates AS (
            SELECT DISTINCT trade_date
            FROM all_stocks_days
            WHERE trade_date &lt;= #{startDate}
            ORDER BY trade_date DESC
            LIMIT 41
        ),
        next_dates AS (
            SELECT DISTINCT trade_date
            FROM all_stocks_days
            WHERE trade_date &gt;= #{startDate}
            ORDER BY trade_date ASC
            LIMIT 41
        ),
        date_range AS (
            SELECT 
                (SELECT MIN(trade_date) FROM prev_dates) AS start_date,
                (SELECT MAX(trade_date) FROM next_dates) AS end_date
        )
        SELECT a.id, a.ts_code, a.trade_date, a.open, a.high, a.low, a.close, a.pct_chg, a.vol, 
               a.amount, a.state,
               COALESCE(NULLIF(a.ma120, 'NaN'), NULL) as ma120, 
               COALESCE(NULLIF(a.ma250, 'NaN'), NULL) as ma250,
               a.name
        FROM all_stocks_days a
        JOIN limit_up_stocks l ON a.ts_code = l.ts_code
        JOIN date_range d ON a.trade_date BETWEEN d.start_date AND d.end_date
        ORDER BY a.ts_code, a.trade_date ASC
    </select>

    <!-- 
        查询跌停股票数据 
        跌停标准为跌幅小于等于-6.0%
        使用CTE结构:
        1. limit_down_stocks: 筛选指定日期跌幅&lt;=-6.0%的股票
        2. prev_dates和next_dates: 获取前后各41个交易日
        3. date_range: 确定日期范围
        最终返回符合条件股票在日期范围内的所有交易数据
    -->
    <select id="findLimitDown" resultType="com.example.stock.entity.StockData">
        WITH limit_down_stocks AS (
            SELECT DISTINCT a.ts_code, a.pct_chg
            FROM all_stocks_days a
            <where>
                <if test="tsCode != null">
                    a.ts_code = #{tsCode} AND
                </if>
                a.trade_date = #{startDate} AND a.pct_chg &lt;= -6.0
            </where>
            ORDER BY a.pct_chg ASC
            LIMIT #{pageSize} OFFSET #{offset}
        ),
        prev_dates AS (
            SELECT DISTINCT trade_date
            FROM all_stocks_days
            WHERE trade_date &lt;= #{startDate}
            ORDER BY trade_date DESC
            LIMIT 41
        ),
        next_dates AS (
            SELECT DISTINCT trade_date
            FROM all_stocks_days
            WHERE trade_date &gt;= #{startDate}
            ORDER BY trade_date ASC
            LIMIT 41
        ),
        date_range AS (
            SELECT 
                (SELECT MIN(trade_date) FROM prev_dates) AS start_date,
                (SELECT MAX(trade_date) FROM next_dates) AS end_date
        )
        SELECT a.id, a.ts_code, a.trade_date, a.open, a.high, a.low, a.close, a.pct_chg, a.vol, 
               a.amount, a.state,
               COALESCE(NULLIF(a.ma120, 'NaN'), NULL) as ma120, 
               COALESCE(NULLIF(a.ma250, 'NaN'), NULL) as ma250,
               a.name
        FROM all_stocks_days a
        JOIN limit_down_stocks l ON a.ts_code = l.ts_code
        JOIN date_range d ON a.trade_date BETWEEN d.start_date AND d.end_date
        ORDER BY a.ts_code, a.trade_date ASC
    </select>

    <!-- 获取数据库中的最早交易日期 -->
    <select id="findMinDate" resultType="java.lang.String">
        SELECT MIN(trade_date)
        FROM all_stocks_days
    </select>

    <!-- 获取数据库中的最新交易日期 -->
    <select id="findMaxDate" resultType="java.lang.String">
        SELECT MAX(trade_date)
        FROM all_stocks_days
    </select>

    <!-- 
        查询指定日期之后的第n个交易日
        先获取日期之后的n个交易日，然后选择第n个
     -->
    <select id="findNextNthTradeDate" resultType="java.lang.String">
        SELECT trade_date
        FROM (
            SELECT DISTINCT trade_date
            FROM all_stocks_days
            WHERE trade_date &gt; #{date}
            ORDER BY trade_date ASC
            LIMIT #{n}
        ) AS next_dates
        ORDER BY trade_date DESC
        LIMIT 1
    </select>

    <!-- 
        查询指定日期之前的第n个交易日
        先获取日期之前的n个交易日，然后选择第n个
     -->
    <select id="findPreviousNthTradeDate" resultType="java.lang.String">
        SELECT trade_date
        FROM (
            SELECT DISTINCT trade_date
            FROM all_stocks_days
            WHERE trade_date &lt; #{date}
            ORDER BY trade_date DESC
            LIMIT #{n}
        ) AS prev_dates
        ORDER BY trade_date ASC
        LIMIT 1
    </select>

    <!-- 
        统计股票数量
        根据参数isLimitUp和isLimitDown动态生成不同的SQL:
        1. 涨停股票数量
        2. 跌停股票数量
        3. 全部股票数量
     -->
    <select id="countStocks" resultType="java.lang.Long">
        <if test="isLimitUp != null and isLimitUp">
            SELECT COUNT(DISTINCT a.ts_code)
            FROM all_stocks_days a
            WHERE a.trade_date = #{startDate}
            <if test="tsCode != null">
                AND a.ts_code = #{tsCode}
            </if>
            AND a.pct_chg &gt;= 6.0
        </if>
        <if test="isLimitDown != null and isLimitDown">
            SELECT COUNT(DISTINCT a.ts_code)
            FROM all_stocks_days a
            WHERE a.trade_date = #{startDate}
            <if test="tsCode != null">
                AND a.ts_code = #{tsCode}
            </if>
            AND a.pct_chg &lt;= -6.0
        </if>
        <if test="isLimitUp == null and isLimitDown == null">
            SELECT COUNT(DISTINCT a.ts_code)
            FROM all_stocks_days a
            WHERE a.trade_date = #{startDate}
            <if test="tsCode != null">
                AND a.ts_code = #{tsCode}
            </if>
        </if>
    </select>

    <!-- 
        查询半年线股票数据
        半年线定义为收盘价大于120日均线的股票
        1. half_year_stocks: 筛选收盘价>120日均线的股票
        2. 同样使用前后41个交易日构建日期区间
        3. 返回符合条件的股票在日期区间内的全部交易数据
     -->
    <select id="findHalfYearLine" resultType="com.example.stock.entity.StockData">
        WITH half_year_stocks AS (
            SELECT DISTINCT a.ts_code
            FROM all_stocks_days a
            <where>
            <if test="tsCode != null">
                    a.ts_code = #{tsCode} AND
            </if>
                a.trade_date = #{startDate}
                AND a.close &gt; COALESCE(NULLIF(a.ma120, 'NaN'), 0)
            </where>
            ORDER BY a.ts_code
            LIMIT #{pageSize} OFFSET #{offset}
        ),
        prev_dates AS (
            SELECT DISTINCT trade_date
            FROM all_stocks_days
            WHERE trade_date &lt;= #{startDate}
            ORDER BY trade_date DESC
            LIMIT 41
        ),
        next_dates AS (
            SELECT DISTINCT trade_date
            FROM all_stocks_days
            WHERE trade_date &gt;= #{startDate}
            ORDER BY trade_date ASC
            LIMIT 41
        ),
        date_range AS (
            SELECT 
                (SELECT MIN(trade_date) FROM prev_dates) AS start_date,
                (SELECT MAX(trade_date) FROM next_dates) AS end_date
        )
        SELECT a.id, a.ts_code, a.trade_date, a.open, a.high, a.low, a.close, a.pct_chg, a.vol, 
               a.amount, a.state,
               COALESCE(NULLIF(a.ma120, 'NaN'), NULL) as ma120, 
               COALESCE(NULLIF(a.ma250, 'NaN'), NULL) as ma250,
               a.name
        FROM all_stocks_days a
        JOIN half_year_stocks h ON a.ts_code = h.ts_code
        JOIN date_range d ON a.trade_date BETWEEN d.start_date AND d.end_date
        ORDER BY a.ts_code, a.trade_date ASC
    </select>

    <!-- 
        查询年线股票数据
        年线定义为收盘价大于250日均线的股票
        1. year_stocks: 筛选收盘价>250日均线的股票
        2. 同样使用前后41个交易日构建日期区间
        3. 返回符合条件的股票在日期区间内的全部交易数据
     -->
    <select id="findYearLine" resultType="com.example.stock.entity.StockData">
        WITH year_stocks AS (
            SELECT DISTINCT a.ts_code
            FROM all_stocks_days a
            <where>
            <if test="tsCode != null">
                    a.ts_code = #{tsCode} AND
            </if>
                a.trade_date = #{startDate}
                AND a.close &gt; COALESCE(NULLIF(a.ma250, 'NaN'), 0)
            </where>
            ORDER BY a.ts_code
            LIMIT #{pageSize} OFFSET #{offset}
        ),
        prev_dates AS (
            SELECT DISTINCT trade_date
            FROM all_stocks_days
            WHERE trade_date &lt;= #{startDate}
            ORDER BY trade_date DESC
            LIMIT 41
        ),
        next_dates AS (
            SELECT DISTINCT trade_date
            FROM all_stocks_days
            WHERE trade_date &gt;= #{startDate}
            ORDER BY trade_date ASC
            LIMIT 41
        ),
        date_range AS (
            SELECT 
                (SELECT MIN(trade_date) FROM prev_dates) AS start_date,
                (SELECT MAX(trade_date) FROM next_dates) AS end_date
        )
        SELECT a.id, a.ts_code, a.trade_date, a.open, a.high, a.low, a.close, a.pct_chg, a.vol, 
               a.amount, a.state,
               COALESCE(NULLIF(a.ma120, 'NaN'), NULL) as ma120, 
               COALESCE(NULLIF(a.ma250, 'NaN'), NULL) as ma250,
               a.name
        FROM all_stocks_days a
        JOIN year_stocks y ON a.ts_code = y.ts_code
        JOIN date_range d ON a.trade_date BETWEEN d.start_date AND d.end_date
        ORDER BY a.ts_code, a.trade_date ASC
    </select>

    <!-- 
        统计符合半年线条件的股票数量
        计算在指定日期收盘价大于120日均线的股票数量
     -->
    <select id="countHalfYearLineStocks" resultType="java.lang.Long">
        SELECT COUNT(DISTINCT a.ts_code)
        FROM all_stocks_days a
        WHERE a.trade_date = #{startDate}
        <if test="tsCode != null">
            AND a.ts_code = #{tsCode}
        </if>
        AND a.close &gt; COALESCE(NULLIF(a.ma120, 'NaN'), 0)
    </select>

    <!-- 
        统计符合年线条件的股票数量
        计算在指定日期收盘价大于250日均线的股票数量
     -->
    <select id="countYearLineStocks" resultType="java.lang.Long">
        SELECT COUNT(DISTINCT a.ts_code)
        FROM all_stocks_days a
        WHERE a.trade_date = #{startDate}
        <if test="tsCode != null">
            AND a.ts_code = #{tsCode}
        </if>
        AND a.close &gt; COALESCE(NULLIF(a.ma250, 'NaN'), 0)
    </select>

    <!-- 
        查询强于大盘的股票数据
        强于大盘定义为股票斜率大于上证指数斜率的股票
        1. 实时计算股票斜率，不再依赖stock_slope表
        2. 与上证指数的斜率进行比较
        3. 使用前后41个交易日构建日期区间
        4. 返回符合条件的股票在日期区间内的全部交易数据
     -->
    <select id="findOutperformData" resultType="com.example.stock.entity.StockData">
        WITH market_slope AS (
            SELECT slope
            FROM shangzheng
            WHERE trade_date = #{startDate}
            LIMIT 1
        ),
        -- 预先获取所有股票代码，减少后续重复查询
        all_stocks AS (
            SELECT 
                a.ts_code,
                a.close,
                a.trade_date,
                (
                    SELECT fp.close
                    FROM all_stocks_days fp
                    WHERE fp.ts_code = a.ts_code AND fp.Fmark IN (0, 1)
                      AND fp.trade_date &lt; a.trade_date
                    ORDER BY fp.trade_date DESC
                    LIMIT 1
                ) AS prev_close,
                (
                    SELECT fp.trade_date
                    FROM all_stocks_days fp
                    WHERE fp.ts_code = a.ts_code AND fp.Fmark IN (0, 1)
                      AND fp.trade_date &lt; a.trade_date
                    ORDER BY fp.trade_date DESC
                    LIMIT 1
                ) AS prev_date
            FROM all_stocks_days a
            WHERE a.trade_date = #{startDate}
            <if test="tsCode != null">
                AND a.ts_code = #{tsCode}
            </if>
        ),
        -- 计算斜率，简化计算逻辑并提高性能
        slopes AS (
            SELECT 
                s.ts_code,
                CASE
                    WHEN s.prev_close IS NOT NULL THEN
                        (s.close - s.prev_close) / NULLIF(s.prev_close, 0) * 100 /
                        NULLIF(DATEDIFF(s.trade_date, s.prev_date), 0)
                    ELSE 0
                END AS stock_slope
            FROM all_stocks s
        ),
        -- 筛选强于大盘的股票
        outperform_stocks AS (
            SELECT s.ts_code
            FROM slopes s, market_slope m
            WHERE s.stock_slope &gt; m.slope
            LIMIT #{pageSize} OFFSET #{offset}
        ),
        -- 获取日期范围
        date_range AS (
            SELECT
                (SELECT DATE_SUB(#{startDate}, INTERVAL 40 DAY)) AS start_date,
                (SELECT DATE_ADD(#{startDate}, INTERVAL 40 DAY)) AS end_date
        )
        -- 获取符合条件的所有数据
        SELECT a.id, a.ts_code, a.trade_date, a.open, a.high, a.low, a.close, a.pct_chg, a.vol, 
               a.amount, a.state,
               COALESCE(NULLIF(a.ma120, 'NaN'), NULL) as ma120, 
               COALESCE(NULLIF(a.ma250, 'NaN'), NULL) as ma250,
               a.name
        FROM all_stocks_days a
        JOIN outperform_stocks o ON a.ts_code = o.ts_code
        JOIN date_range d ON a.trade_date BETWEEN d.start_date AND d.end_date
        ORDER BY a.ts_code, a.trade_date ASC
    </select>

    <!-- 
        统计强于大盘的股票数量
        使用实时计算的斜率进行比较
     -->
    <select id="countOutperformStocks" resultType="java.lang.Long">
        WITH market_slope AS (
            SELECT slope
            FROM shangzheng
            WHERE trade_date = #{startDate}
            LIMIT 1
        ),
        all_stocks AS (
            SELECT 
                a.ts_code,
                a.close,
                a.trade_date,
                (
                    SELECT fp.close
                    FROM all_stocks_days fp
                    WHERE fp.ts_code = a.ts_code AND fp.Fmark IN (0, 1)
                      AND fp.trade_date &lt; a.trade_date
                    ORDER BY fp.trade_date DESC
                    LIMIT 1
                ) AS prev_close,
                (
                    SELECT fp.trade_date
                    FROM all_stocks_days fp
                    WHERE fp.ts_code = a.ts_code AND fp.Fmark IN (0, 1)
                      AND fp.trade_date &lt; a.trade_date
                    ORDER BY fp.trade_date DESC
                    LIMIT 1
                ) AS prev_date
            FROM all_stocks_days a
            WHERE a.trade_date = #{startDate}
            <if test="tsCode != null">
                AND a.ts_code = #{tsCode}
            </if>
        ),
        slopes AS (
            SELECT 
                s.ts_code,
                CASE
                    WHEN s.prev_close IS NOT NULL THEN
                        (s.close - s.prev_close) / NULLIF(s.prev_close, 0) * 100 /
                        NULLIF(DATEDIFF(s.trade_date, s.prev_date), 0)
                    ELSE 0
                END AS stock_slope
            FROM all_stocks s
        )
        SELECT COUNT(*)
        FROM slopes s, market_slope m
        WHERE s.stock_slope &gt; m.slope
    </select>

    <!-- 
        弱于大盘股票数据查询
        弱于大盘定义为股票斜率小于上证指数斜率的股票
        1. 实时计算股票斜率，不再依赖stock_slope表
        2. 与上证指数的斜率进行比较
        3. 使用前后41个交易日构建日期区间
        4. 返回符合条件的股票在日期区间内的全部交易数据
     -->
    <select id="findUnderperformData" resultType="com.example.stock.entity.StockData">
        WITH market_slope AS (
            SELECT slope
            FROM shangzheng
            WHERE trade_date = #{startDate}
            LIMIT 1
        ),
        -- 预先获取所有股票代码，减少后续重复查询
        all_stocks AS (
            SELECT 
                a.ts_code,
                a.close,
                a.trade_date,
                (
                    SELECT fp.close
                    FROM all_stocks_days fp
                    WHERE fp.ts_code = a.ts_code AND fp.Fmark IN (0, 1)
                      AND fp.trade_date &lt; a.trade_date
                    ORDER BY fp.trade_date DESC
                    LIMIT 1
                ) AS prev_close,
                (
                    SELECT fp.trade_date
                    FROM all_stocks_days fp
                    WHERE fp.ts_code = a.ts_code AND fp.Fmark IN (0, 1)
                      AND fp.trade_date &lt; a.trade_date
                    ORDER BY fp.trade_date DESC
                    LIMIT 1
                ) AS prev_date
            FROM all_stocks_days a
            WHERE a.trade_date = #{startDate}
            <if test="tsCode != null">
                AND a.ts_code = #{tsCode}
            </if>
        ),
        -- 计算斜率，简化计算逻辑并提高性能
        slopes AS (
            SELECT 
                s.ts_code,
                CASE
                    WHEN s.prev_close IS NOT NULL THEN
                        (s.close - s.prev_close) / NULLIF(s.prev_close, 0) * 100 /
                        NULLIF(DATEDIFF(s.trade_date, s.prev_date), 0)
                    ELSE 0
                END AS stock_slope
            FROM all_stocks s
        ),
        -- 筛选弱于大盘的股票
        underperform_stocks AS (
            SELECT s.ts_code
            FROM slopes s, market_slope m
            WHERE s.stock_slope &lt; m.slope
            LIMIT #{pageSize} OFFSET #{offset}
        ),
        -- 获取日期范围
        date_range AS (
            SELECT
                (SELECT DATE_SUB(#{startDate}, INTERVAL 40 DAY)) AS start_date,
                (SELECT DATE_ADD(#{startDate}, INTERVAL 40 DAY)) AS end_date
        )
        -- 获取符合条件的所有数据
        SELECT a.id, a.ts_code, a.trade_date, a.open, a.high, a.low, a.close, a.pct_chg, a.vol, 
               a.amount, a.state,
               COALESCE(NULLIF(a.ma120, 'NaN'), NULL) as ma120, 
               COALESCE(NULLIF(a.ma250, 'NaN'), NULL) as ma250,
               a.name
        FROM all_stocks_days a
        JOIN underperform_stocks u ON a.ts_code = u.ts_code
        JOIN date_range d ON a.trade_date BETWEEN d.start_date AND d.end_date
        ORDER BY a.ts_code, a.trade_date ASC
    </select>

    <!-- 
        统计弱于大盘的股票数量
        使用实时计算的斜率进行比较
     -->
    <select id="countUnderperformStocks" resultType="java.lang.Long">
        WITH market_slope AS (
            SELECT slope
            FROM shangzheng
            WHERE trade_date = #{startDate}
            LIMIT 1
        ),
        all_stocks AS (
            SELECT 
                a.ts_code,
                a.close,
                a.trade_date,
                (
                    SELECT fp.close
                    FROM all_stocks_days fp
                    WHERE fp.ts_code = a.ts_code AND fp.Fmark IN (0, 1)
                      AND fp.trade_date &lt; a.trade_date
                    ORDER BY fp.trade_date DESC
                    LIMIT 1
                ) AS prev_close,
                (
                    SELECT fp.trade_date
                    FROM all_stocks_days fp
                    WHERE fp.ts_code = a.ts_code AND fp.Fmark IN (0, 1)
                      AND fp.trade_date &lt; a.trade_date
                    ORDER BY fp.trade_date DESC
                    LIMIT 1
                ) AS prev_date
            FROM all_stocks_days a
            WHERE a.trade_date = #{startDate}
            <if test="tsCode != null">
                AND a.ts_code = #{tsCode}
            </if>
        ),
        slopes AS (
            SELECT 
                s.ts_code,
                CASE
                    WHEN s.prev_close IS NOT NULL THEN
                        (s.close - s.prev_close) / NULLIF(s.prev_close, 0) * 100 /
                        NULLIF(DATEDIFF(s.trade_date, s.prev_date), 0)
                    ELSE 0
                END AS stock_slope
            FROM all_stocks s
        )
        SELECT COUNT(*)
        FROM slopes s, market_slope m
        WHERE s.stock_slope &lt; m.slope
    </select>

    <!-- 
        查询具有买点的五日调整股票数据
        五日调整是指满足特定技术指标条件的股票
        1. five_day_adjustment_stocks: 筛选state字段等于1的股票（表示有买点）
        2. 同样使用前后41个交易日构建日期区间
        3. 返回符合条件的股票在日期区间内的全部交易数据
        4. 注意state字段在这里作为买点指标保留原始值
     -->
    <select id="findFiveDayAdjustmentStocks" resultType="com.example.stock.entity.StockData">
        WITH five_day_adjustment_stocks AS (
            SELECT DISTINCT a.ts_code
            FROM all_stocks_days a
            <where>
                <if test="tsCode != null and tsCode != ''">
                    a.ts_code = #{tsCode} AND
                </if>
                a.trade_date = #{startDate}
                AND a.state = 1 -- 使用state字段大于0作为买入点判断
            </where>
            ORDER BY a.ts_code
            LIMIT #{pageSize} OFFSET #{offset}
        ),
        prev_dates AS (
            SELECT DISTINCT trade_date
            FROM all_stocks_days
            WHERE trade_date &lt;= #{startDate}
            ORDER BY trade_date DESC
            LIMIT 41
        ),
        next_dates AS (
            SELECT DISTINCT trade_date
            FROM all_stocks_days
            WHERE trade_date &gt;= #{startDate}
            ORDER BY trade_date ASC
            LIMIT 41
        ),
        date_range AS (
            SELECT 
                (SELECT MIN(trade_date) FROM prev_dates) AS start_date,
                (SELECT MAX(trade_date) FROM next_dates) AS end_date
        )
        SELECT a.id, a.ts_code, a.trade_date, a.open, a.high, a.low, a.close, a.pct_chg, a.vol, 
               a.amount, a.state,
               COALESCE(NULLIF(a.ma120, 'NaN'), NULL) as ma120, 
               COALESCE(NULLIF(a.ma250, 'NaN'), NULL) as ma250,
               a.name
        FROM all_stocks_days a
        JOIN five_day_adjustment_stocks ts ON a.ts_code = ts.ts_code
        JOIN date_range d ON a.trade_date BETWEEN d.start_date AND d.end_date
        ORDER BY a.ts_code, a.trade_date ASC
    </select>

    <!-- 
        获取具有买点的五日调整股票代码列表
        返回在指定日期state字段等于1的所有股票代码
        用于前端展示和统计
     -->
    <select id="findFiveDayAdjustmentTsCodes" resultType="java.lang.String">
        SELECT DISTINCT a.ts_code
        FROM all_stocks_days a
        <where>
            a.trade_date = #{startDate}
            <if test="tsCode != null and tsCode != ''">
                AND a.ts_code = #{tsCode}
            </if>
            AND a.state = 1 -- 使用state字段大于0作为买入点判断
        </where>
        ORDER BY a.ts_code
    </select>

    <!-- 
        统计具有买点的五日调整股票数量
        计算在指定日期state字段等于1的股票数量
        用于分页和统计展示
     -->
    <select id="countFiveDayAdjustmentStocks" resultType="java.lang.Long">
        SELECT COUNT(DISTINCT a.ts_code)
        FROM all_stocks_days a
        <where>
            a.trade_date = #{startDate}
            <if test="tsCode != null and tsCode != ''">
                AND a.ts_code = #{tsCode}
            </if>
            AND a.state = 1 -- 使用state字段大于0作为买入点判断
        </where>
    </select>
    <select id="getSingleStockData" resultType="com.example.stock.entity.StockData">
        SELECT 
            id,
            ts_code,
            trade_date,
            open,
            high,
            low,
            close,
            pct_chg,
            vol,
            amount,
            state,
            Fmark,
            COALESCE(NULLIF(ma120, 'NaN'), NULL) as ma120,
            COALESCE(NULLIF(ma250, 'NaN'), NULL) as ma250,
            name
        FROM all_stocks_days
        WHERE ts_code = #{tsCode}
        ORDER BY trade_date ASC
    </select>

    <!-- 
        查询具有MACD金叉信号的股票数据
        MACD金叉是指macd_golden_state字段等于1的股票
        1. macd_golden_stocks: 筛选macd_golden_state字段等于1的股票
        2. 同样使用前后41个交易日构建日期区间
        3. 返回符合条件的股票在日期区间内的全部交易数据
        4. 注意macd_golden_state字段作为信号指标保留原始值
     -->
    <select id="findMacdGoldenCrossStocks" resultType="com.example.stock.entity.StockData">
        WITH macd_golden_stocks AS (
            SELECT DISTINCT a.ts_code
            FROM all_stocks_days a
            <where>
                <if test="tsCode != null and tsCode != ''">
                    a.ts_code = #{tsCode} AND
                </if>
                a.trade_date = #{startDate}
                AND a.macd_golden_state = 1 -- 使用macd_golden_state字段等于1作为信号判断
            </where>
            ORDER BY a.ts_code
            LIMIT #{pageSize} OFFSET #{offset}
        ),
        prev_dates AS (
            SELECT DISTINCT trade_date
            FROM all_stocks_days
            WHERE trade_date &lt;= #{startDate}
            ORDER BY trade_date DESC
            LIMIT 41
        ),
        next_dates AS (
            SELECT DISTINCT trade_date
            FROM all_stocks_days
            WHERE trade_date &gt;= #{startDate}
            ORDER BY trade_date ASC
            LIMIT 41
        ),
        date_range AS (
            SELECT 
                (SELECT MIN(trade_date) FROM prev_dates) AS start_date,
                (SELECT MAX(trade_date) FROM next_dates) AS end_date
        )
        SELECT a.id, a.ts_code, a.trade_date, a.open, a.high, a.low, a.close, a.pct_chg, a.vol, 
               a.amount, a.macd_golden_state as state,
               COALESCE(NULLIF(a.ma120, 'NaN'), NULL) as ma120, 
               COALESCE(NULLIF(a.ma250, 'NaN'), NULL) as ma250,
               a.name
        FROM all_stocks_days a
        JOIN macd_golden_stocks ts ON a.ts_code = ts.ts_code
        JOIN date_range d ON a.trade_date BETWEEN d.start_date AND d.end_date
        ORDER BY a.ts_code, a.trade_date ASC
    </select>

    <!-- 
        获取具有MACD金叉信号的股票代码列表
        返回在指定日期macd_golden_state字段等于1的所有股票代码
        用于前端展示和统计
     -->
    <select id="findMacdGoldenCrossTsCodes" resultType="java.lang.String">
        SELECT DISTINCT a.ts_code
        FROM all_stocks_days a
        <where>
            a.trade_date = #{startDate}
            <if test="tsCode != null and tsCode != ''">
                AND a.ts_code = #{tsCode}
            </if>
            AND a.macd_golden_state = 1 -- 使用macd_golden_state字段等于1作为信号判断
        </where>
        ORDER BY a.ts_code
    </select>

    <!-- 
        统计具有MACD金叉信号的股票数量
        计算在指定日期macd_golden_state字段等于1的股票数量
        用于分页和统计展示
     -->
    <select id="countMacdGoldenCrossStocks" resultType="java.lang.Long">
        SELECT COUNT(DISTINCT a.ts_code)
        FROM all_stocks_days a
        <where>
            a.trade_date = #{startDate}
            <if test="tsCode != null and tsCode != ''">
                AND a.ts_code = #{tsCode}
            </if>
            AND a.macd_golden_state = 1 -- 使用macd_golden_state字段等于1作为信号判断
        </where>
    </select>
    
    <!-- 
        查询具有KDJ金叉信号的股票数据
        KDJ金叉是指kdj_gloden_state字段等于1的股票
        1. kdj_golden_stocks: 筛选kdj_gloden_state字段等于1的股票
        2. 同样使用前后41个交易日构建日期区间
        3. 返回符合条件的股票在日期区间内的全部交易数据
        4. 注意kdj_gloden_state字段作为信号指标保留原始值
     -->
    <select id="findKdjGoldenCrossStocks" resultType="com.example.stock.entity.StockData">
        WITH kdj_golden_stocks AS (
            SELECT DISTINCT a.ts_code
            FROM all_stocks_days a
            <where>
                <if test="tsCode != null and tsCode != ''">
                    a.ts_code = #{tsCode} AND
                </if>
                a.trade_date = #{startDate}
                AND a.kdj_gloden_state = 1 -- 使用kdj_gloden_state字段等于1作为信号判断
            </where>
            ORDER BY a.ts_code
            LIMIT #{pageSize} OFFSET #{offset}
        ),
        prev_dates AS (
            SELECT DISTINCT trade_date
            FROM all_stocks_days
            WHERE trade_date &lt;= #{startDate}
            ORDER BY trade_date DESC
            LIMIT 41
        ),
        next_dates AS (
            SELECT DISTINCT trade_date
            FROM all_stocks_days
            WHERE trade_date &gt;= #{startDate}
            ORDER BY trade_date ASC
            LIMIT 41
        ),
        date_range AS (
            SELECT 
                (SELECT MIN(trade_date) FROM prev_dates) AS start_date,
                (SELECT MAX(trade_date) FROM next_dates) AS end_date
        )
        SELECT a.id, a.ts_code, a.trade_date, a.open, a.high, a.low, a.close, a.pct_chg, a.vol, 
               a.amount, a.kdj_gloden_state as state,
               COALESCE(NULLIF(a.ma120, 'NaN'), NULL) as ma120, 
               COALESCE(NULLIF(a.ma250, 'NaN'), NULL) as ma250,
               a.name
        FROM all_stocks_days a
        JOIN kdj_golden_stocks ts ON a.ts_code = ts.ts_code
        JOIN date_range d ON a.trade_date BETWEEN d.start_date AND d.end_date
        ORDER BY a.ts_code, a.trade_date ASC
    </select>

    <!-- 
        获取具有KDJ金叉信号的股票代码列表
        返回在指定日期kdj_gloden_state字段等于1的所有股票代码
        用于前端展示和统计
     -->
    <select id="findKdjGoldenCrossTsCodes" resultType="java.lang.String">
        SELECT DISTINCT a.ts_code
        FROM all_stocks_days a
        <where>
            a.trade_date = #{startDate}
            <if test="tsCode != null and tsCode != ''">
                AND a.ts_code = #{tsCode}
            </if>
            AND a.kdj_gloden_state = 1 -- 使用kdj_gloden_state字段等于1作为信号判断
        </where>
        ORDER BY a.ts_code
    </select>

    <!-- 
        统计具有KDJ金叉信号的股票数量
        计算在指定日期kdj_gloden_state字段等于1的股票数量
        用于分页和统计展示
     -->
    <select id="countKdjGoldenCrossStocks" resultType="java.lang.Long">
        SELECT COUNT(DISTINCT a.ts_code)
        FROM all_stocks_days a
        <where>
            a.trade_date = #{startDate}
            <if test="tsCode != null and tsCode != ''">
                AND a.ts_code = #{tsCode}
            </if>
            AND a.kdj_gloden_state = 1 -- 使用kdj_gloden_state字段等于1作为信号判断
        </where>
    </select>
    
    <!-- 
        查询具有低位资金净流入信号的股票数据
        低位资金净流入是指low_price_state字段等于1的股票
        1. low_price_stocks: 筛选low_price_state字段等于1的股票
        2. 同样使用前后41个交易日构建日期区间
        3. 返回符合条件的股票在日期区间内的全部交易数据
        4. 注意low_price_state字段作为信号指标保留原始值
     -->
    <select id="findLowPriceInflowStocks" resultType="com.example.stock.entity.StockData">
        WITH low_price_stocks AS (
            SELECT DISTINCT a.ts_code
            FROM all_stocks_days a
            <where>
                <if test="tsCode != null and tsCode != ''">
                    a.ts_code = #{tsCode} AND
                </if>
                a.trade_date = #{startDate}
                AND a.low_price_state = 1 -- 使用low_price_state字段等于1作为信号判断
            </where>
            ORDER BY a.ts_code
            LIMIT #{pageSize} OFFSET #{offset}
        ),
        prev_dates AS (
            SELECT DISTINCT trade_date
            FROM all_stocks_days
            WHERE trade_date &lt;= #{startDate}
            ORDER BY trade_date DESC
            LIMIT 41
        ),
        next_dates AS (
            SELECT DISTINCT trade_date
            FROM all_stocks_days
            WHERE trade_date &gt;= #{startDate}
            ORDER BY trade_date ASC
            LIMIT 41
        ),
        date_range AS (
            SELECT 
                (SELECT MIN(trade_date) FROM prev_dates) AS start_date,
                (SELECT MAX(trade_date) FROM next_dates) AS end_date
        )
        SELECT a.id, a.ts_code, a.trade_date, a.open, a.high, a.low, a.close, a.pct_chg, a.vol, 
               a.amount, a.low_price_state as state,
               COALESCE(NULLIF(a.ma120, 'NaN'), NULL) as ma120, 
               COALESCE(NULLIF(a.ma250, 'NaN'), NULL) as ma250,
               a.name
        FROM all_stocks_days a
        JOIN low_price_stocks ts ON a.ts_code = ts.ts_code
        JOIN date_range d ON a.trade_date BETWEEN d.start_date AND d.end_date
        ORDER BY a.ts_code, a.trade_date ASC
    </select>

    <!-- 
        获取具有低位资金净流入信号的股票代码列表
        返回在指定日期low_price_state字段等于1的所有股票代码
        用于前端展示和统计
     -->
    <select id="findLowPriceInflowTsCodes" resultType="java.lang.String">
        SELECT DISTINCT a.ts_code
        FROM all_stocks_days a
        <where>
            a.trade_date = #{startDate}
            <if test="tsCode != null and tsCode != ''">
                AND a.ts_code = #{tsCode}
            </if>
            AND a.low_price_state = 1 -- 使用low_price_state字段等于1作为信号判断
        </where>
        ORDER BY a.ts_code
    </select>

    <!-- 
        统计具有低位资金净流入信号的股票数量
        计算在指定日期low_price_state字段等于1的股票数量
        用于分页和统计展示
     -->
    <select id="countLowPriceInflowStocks" resultType="java.lang.Long">
        SELECT COUNT(DISTINCT a.ts_code)
        FROM all_stocks_days a
        <where>
            a.trade_date = #{startDate}
            <if test="tsCode != null and tsCode != ''">
                AND a.ts_code = #{tsCode}
            </if>
            AND a.low_price_state = 1 -- 使用low_price_state字段等于1作为信号判断
        </where>
    </select>
    
    <!-- 
        查询具有高位资金净流出信号的股票数据
        高位资金净流出是指high_level_state字段等于1的股票
        1. high_level_stocks: 筛选high_level_state字段等于1的股票
        2. 同样使用前后41个交易日构建日期区间
        3. 返回符合条件的股票在日期区间内的全部交易数据
        4. 注意high_level_state字段作为信号指标保留原始值
     -->
    <select id="findHighLevelOutflowStocks" resultType="com.example.stock.entity.StockData">
        WITH high_level_stocks AS (
            SELECT DISTINCT a.ts_code
            FROM all_stocks_days a
            <where>
                <if test="tsCode != null and tsCode != ''">
                    a.ts_code = #{tsCode} AND
                </if>
                a.trade_date = #{startDate}
                AND a.high_level_state = 1 -- 使用high_level_state字段等于1作为信号判断
            </where>
            ORDER BY a.ts_code
            LIMIT #{pageSize} OFFSET #{offset}
        ),
        prev_dates AS (
            SELECT DISTINCT trade_date
            FROM all_stocks_days
            WHERE trade_date &lt;= #{startDate}
            ORDER BY trade_date DESC
            LIMIT 41
        ),
        next_dates AS (
            SELECT DISTINCT trade_date
            FROM all_stocks_days
            WHERE trade_date &gt;= #{startDate}
            ORDER BY trade_date ASC
            LIMIT 41
        ),
        date_range AS (
            SELECT 
                (SELECT MIN(trade_date) FROM prev_dates) AS start_date,
                (SELECT MAX(trade_date) FROM next_dates) AS end_date
        )
        SELECT a.id, a.ts_code, a.trade_date, a.open, a.high, a.low, a.close, a.pct_chg, a.vol, 
               a.amount, a.high_level_state as state,
               COALESCE(NULLIF(a.ma120, 'NaN'), NULL) as ma120, 
               COALESCE(NULLIF(a.ma250, 'NaN'), NULL) as ma250,
               a.name
        FROM all_stocks_days a
        JOIN high_level_stocks ts ON a.ts_code = ts.ts_code
        JOIN date_range d ON a.trade_date BETWEEN d.start_date AND d.end_date
        ORDER BY a.ts_code, a.trade_date ASC
    </select>

    <!-- 
        获取具有高位资金净流出信号的股票代码列表
        返回在指定日期high_level_state字段等于1的所有股票代码
        用于前端展示和统计
     -->
    <select id="findHighLevelOutflowTsCodes" resultType="java.lang.String">
        SELECT DISTINCT a.ts_code
        FROM all_stocks_days a
        <where>
            a.trade_date = #{startDate}
            <if test="tsCode != null and tsCode != ''">
                AND a.ts_code = #{tsCode}
            </if>
            AND a.high_level_state = 1 -- 使用high_level_state字段等于1作为信号判断
        </where>
        ORDER BY a.ts_code
    </select>

    <!-- 
        统计具有高位资金净流出信号的股票数量
        计算在指定日期high_level_state字段等于1的股票数量
        用于分页和统计展示
     -->
    <select id="countHighLevelOutflowStocks" resultType="java.lang.Long">
        SELECT COUNT(DISTINCT a.ts_code)
        FROM all_stocks_days a
        <where>
            a.trade_date = #{startDate}
            <if test="tsCode != null and tsCode != ''">
                AND a.ts_code = #{tsCode}
            </if>
            AND a.high_level_state = 1 -- 使用high_level_state字段等于1作为信号判断
        </where>
    </select>

    <!-- 
        查询指定股票在指定日期的斜率
        实时计算特定股票在指定日期的斜率值
        斜率表示股价的趋势，用于判断股票走势强弱
     -->
    <select id="findStockSlope" resultType="java.lang.Double">
        WITH stock_data AS (
            SELECT 
                a.close AS current_close,
                a.trade_date AS curr_date,
                (
                    -- 获取前一个Fmark点数据
                    SELECT fp.close
                    FROM all_stocks_days fp
                    WHERE fp.ts_code = #{tsCode}
                    AND fp.trade_date &lt; #{tradeDate}
                    AND fp.Fmark IN (0, 1)
                    ORDER BY fp.trade_date DESC
                    LIMIT 1
                ) AS prev_close,
                (
                    -- 获取前一个Fmark点日期
                    SELECT fp.trade_date
                    FROM all_stocks_days fp
                    WHERE fp.ts_code = #{tsCode}
                    AND fp.trade_date &lt; #{tradeDate}
                    AND fp.Fmark IN (0, 1)
                    ORDER BY fp.trade_date DESC
                    LIMIT 1
                ) AS prev_date,
                (
                    -- 如果没有前一个Fmark点，获取最早的日期数据
                    SELECT fp.close
                    FROM all_stocks_days fp
                    WHERE fp.ts_code = #{tsCode}
                    AND fp.trade_date &lt; #{tradeDate}
                    ORDER BY fp.trade_date ASC
                    LIMIT 1
                ) AS earliest_close,
                (
                    -- 如果没有前一个Fmark点，获取最早的日期
                    SELECT fp.trade_date
                    FROM all_stocks_days fp
                    WHERE fp.ts_code = #{tsCode}
                    AND fp.trade_date &lt; #{tradeDate}
                    ORDER BY fp.trade_date ASC
                    LIMIT 1
                ) AS earliest_date
            FROM all_stocks_days a
            WHERE a.ts_code = #{tsCode}
            AND a.trade_date = #{tradeDate}
        )
        SELECT 
            CASE 
                WHEN sd.prev_close IS NOT NULL THEN
                    (sd.current_close - sd.prev_close) / sd.prev_close / 
                    (SELECT COUNT(*) FROM all_stocks_days 
                     WHERE ts_code = #{tsCode} 
                     AND trade_date &gt; sd.prev_date 
                     AND trade_date &lt;= sd.curr_date)
                ELSE
                    (sd.current_close - sd.earliest_close) / sd.earliest_close / 
                    (SELECT COUNT(*) FROM all_stocks_days 
                     WHERE ts_code = #{tsCode} 
                     AND trade_date &gt;= sd.earliest_date 
                     AND trade_date &lt;= sd.curr_date)
            END * 100 AS slope
        FROM stock_data sd
        LIMIT 1
    </select>

    <!-- 
        查询指定日期的市场斜率
        从shangzheng表中获取特定日期的上证指数斜率
        用于衡量整体市场趋势，与个股斜率比较可判断强弱
     -->
    <select id="findMarketSlope" resultType="java.lang.Double">
        SELECT slope
        FROM shangzheng
        WHERE trade_date = #{tradeDate}
        LIMIT 1
    </select>
</mapper> 