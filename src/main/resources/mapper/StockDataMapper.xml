<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.example.stock.mapper.StockDataMapper">
    <!-- 
        根据日期范围查询股票数据 
        使用CTE(Common Table Expressions)实现复杂查询：
        1. stock_codes: 获取指定日期的股票代码，支持分页
        2. prev_dates: 获取指定日期前的交易日(最多41天)
        3. next_dates: 获取指定日期后的交易日(最多41天)
        4. date_range: 确定最终的日期范围
        最后连接这些临时表获取完整的股票数据
    -->
    <select id="findByDateRange" resultType="com.example.stock.entity.StockData">
        WITH stock_codes AS (
            SELECT DISTINCT a.ts_code
            FROM all_stocks_days a
            WHERE a.trade_date = #{startDate}
            <if test="tsCode != null">
                AND a.ts_code = #{tsCode}
            </if>
            ORDER BY a.ts_code
            LIMIT #{pageSize} OFFSET #{offset}
        ),
        prev_dates AS (
            SELECT DISTINCT trade_date
            FROM all_stocks_days
            WHERE trade_date &lt;= #{startDate}
            ORDER BY trade_date DESC
            LIMIT 41
        ),
        next_dates AS (
            SELECT DISTINCT trade_date
            FROM all_stocks_days
            WHERE trade_date &gt;= #{startDate}
            ORDER BY trade_date ASC
            LIMIT 41
        ),
        date_range AS (
            SELECT 
                (SELECT MIN(trade_date) FROM prev_dates) AS start_date,
                (SELECT MAX(trade_date) FROM next_dates) AS end_date
        )
        SELECT a.id, a.ts_code, a.trade_date, a.open, a.high, a.low, a.close, a.pct_chg, a.vol, 
               a.amount, a.state,
               COALESCE(NULLIF(a.ma120, 'NaN'), NULL) as ma120, 
               COALESCE(NULLIF(a.ma250, 'NaN'), NULL) as ma250,
               a.name
        FROM all_stocks_days a
        JOIN stock_codes s ON a.ts_code = s.ts_code
        JOIN date_range d ON a.trade_date BETWEEN d.start_date AND d.end_date
        ORDER BY a.ts_code, a.trade_date ASC
    </select>

    <!-- 
        查询涨停股票数据 
        涨停标准为涨幅大于等于6.0%
        使用CTE结构:
        1. limit_up_stocks: 筛选指定日期涨幅>=6.0%的股票
        2. prev_dates和next_dates: 获取前后各41个交易日
        3. date_range: 确定日期范围
        最终返回符合条件股票在日期范围内的所有交易数据
    -->
    <select id="findLimitUp" resultType="com.example.stock.entity.StockData">
        WITH limit_up_stocks AS (
            SELECT DISTINCT a.ts_code, a.pct_chg
            FROM all_stocks_days a
            <where>
                <if test="tsCode != null">
                    a.ts_code = #{tsCode} AND
                </if>
                a.trade_date = #{startDate} AND a.pct_chg &gt;= 6.0
            </where>
            ORDER BY a.pct_chg DESC
            LIMIT #{pageSize} OFFSET #{offset}
        ),
        prev_dates AS (
            SELECT DISTINCT trade_date
            FROM all_stocks_days
            WHERE trade_date &lt;= #{startDate}
            ORDER BY trade_date DESC
            LIMIT 41
        ),
        next_dates AS (
            SELECT DISTINCT trade_date
            FROM all_stocks_days
            WHERE trade_date &gt;= #{startDate}
            ORDER BY trade_date ASC
            LIMIT 41
        ),
        date_range AS (
            SELECT 
                (SELECT MIN(trade_date) FROM prev_dates) AS start_date,
                (SELECT MAX(trade_date) FROM next_dates) AS end_date
        )
        SELECT a.id, a.ts_code, a.trade_date, a.open, a.high, a.low, a.close, a.pct_chg, a.vol, 
               a.amount, a.state,
               COALESCE(NULLIF(a.ma120, 'NaN'), NULL) as ma120, 
               COALESCE(NULLIF(a.ma250, 'NaN'), NULL) as ma250,
               a.name
        FROM all_stocks_days a
        JOIN limit_up_stocks l ON a.ts_code = l.ts_code
        JOIN date_range d ON a.trade_date BETWEEN d.start_date AND d.end_date
        ORDER BY a.ts_code, a.trade_date ASC
    </select>

    <!-- 
        查询跌停股票数据 
        跌停标准为跌幅小于等于-6.0%
        使用CTE结构:
        1. limit_down_stocks: 筛选指定日期跌幅&lt;=-6.0%的股票
        2. prev_dates和next_dates: 获取前后各41个交易日
        3. date_range: 确定日期范围
        最终返回符合条件股票在日期范围内的所有交易数据
    -->
    <select id="findLimitDown" resultType="com.example.stock.entity.StockData">
        WITH limit_down_stocks AS (
            SELECT DISTINCT a.ts_code, a.pct_chg
            FROM all_stocks_days a
            <where>
                <if test="tsCode != null">
                    a.ts_code = #{tsCode} AND
                </if>
                a.trade_date = #{startDate} AND a.pct_chg &lt;= -6.0
            </where>
            ORDER BY a.pct_chg ASC
            LIMIT #{pageSize} OFFSET #{offset}
        ),
        prev_dates AS (
            SELECT DISTINCT trade_date
            FROM all_stocks_days
            WHERE trade_date &lt;= #{startDate}
            ORDER BY trade_date DESC
            LIMIT 41
        ),
        next_dates AS (
            SELECT DISTINCT trade_date
            FROM all_stocks_days
            WHERE trade_date &gt;= #{startDate}
            ORDER BY trade_date ASC
            LIMIT 41
        ),
        date_range AS (
            SELECT 
                (SELECT MIN(trade_date) FROM prev_dates) AS start_date,
                (SELECT MAX(trade_date) FROM next_dates) AS end_date
        )
        SELECT a.id, a.ts_code, a.trade_date, a.open, a.high, a.low, a.close, a.pct_chg, a.vol, 
               a.amount, a.state,
               COALESCE(NULLIF(a.ma120, 'NaN'), NULL) as ma120, 
               COALESCE(NULLIF(a.ma250, 'NaN'), NULL) as ma250,
               a.name
        FROM all_stocks_days a
        JOIN limit_down_stocks l ON a.ts_code = l.ts_code
        JOIN date_range d ON a.trade_date BETWEEN d.start_date AND d.end_date
        ORDER BY a.ts_code, a.trade_date ASC
    </select>

    <!-- 获取数据库中的最早交易日期 -->
    <select id="findMinDate" resultType="java.lang.String">
        SELECT MIN(trade_date)
        FROM all_stocks_days
    </select>

    <!-- 获取数据库中的最新交易日期 -->
    <select id="findMaxDate" resultType="java.lang.String">
        SELECT MAX(trade_date)
        FROM all_stocks_days
    </select>

    <!-- 
        查询指定日期之后的第n个交易日
        先获取日期之后的n个交易日，然后选择第n个
     -->
    <select id="findNextNthTradeDate" resultType="java.lang.String">
        SELECT trade_date
        FROM (
            SELECT DISTINCT trade_date
            FROM all_stocks_days
            WHERE trade_date &gt; #{date}
            ORDER BY trade_date ASC
            LIMIT #{n}
        ) AS next_dates
        ORDER BY trade_date DESC
        LIMIT 1
    </select>

    <!-- 
        查询指定日期之前的第n个交易日
        先获取日期之前的n个交易日，然后选择第n个
     -->
    <select id="findPreviousNthTradeDate" resultType="java.lang.String">
        SELECT trade_date
        FROM (
            SELECT DISTINCT trade_date
            FROM all_stocks_days
            WHERE trade_date &lt; #{date}
            ORDER BY trade_date DESC
            LIMIT #{n}
        ) AS prev_dates
        ORDER BY trade_date ASC
        LIMIT 1
    </select>

    <!-- 
        统计股票数量
        根据参数isLimitUp和isLimitDown动态生成不同的SQL:
        1. 涨停股票数量
        2. 跌停股票数量
        3. 全部股票数量
     -->
    <select id="countStocks" resultType="java.lang.Long">
        <if test="isLimitUp != null and isLimitUp">
            SELECT COUNT(DISTINCT a.ts_code)
            FROM all_stocks_days a
            WHERE a.trade_date = #{startDate}
            <if test="tsCode != null">
                AND a.ts_code = #{tsCode}
            </if>
            AND a.pct_chg &gt;= 6.0
        </if>
        <if test="isLimitDown != null and isLimitDown">
            SELECT COUNT(DISTINCT a.ts_code)
            FROM all_stocks_days a
            WHERE a.trade_date = #{startDate}
            <if test="tsCode != null">
                AND a.ts_code = #{tsCode}
            </if>
            AND a.pct_chg &lt;= -6.0
        </if>
        <if test="isLimitUp == null and isLimitDown == null">
            SELECT COUNT(DISTINCT a.ts_code)
            FROM all_stocks_days a
            WHERE a.trade_date = #{startDate}
            <if test="tsCode != null">
                AND a.ts_code = #{tsCode}
            </if>
        </if>
    </select>

    <!-- 
        查询半年线股票数据
        半年线定义为收盘价大于120日均线的股票
        1. half_year_stocks: 筛选收盘价>120日均线的股票
        2. 同样使用前后41个交易日构建日期区间
        3. 返回符合条件的股票在日期区间内的全部交易数据
     -->
    <select id="findHalfYearLine" resultType="com.example.stock.entity.StockData">
        WITH half_year_stocks AS (
            SELECT DISTINCT a.ts_code
            FROM all_stocks_days a
            <where>
            <if test="tsCode != null">
                    a.ts_code = #{tsCode} AND
            </if>
                a.trade_date = #{startDate}
                AND a.close &gt; COALESCE(NULLIF(a.ma120, 'NaN'), 0)
            </where>
            ORDER BY a.ts_code
            LIMIT #{pageSize} OFFSET #{offset}
        ),
        prev_dates AS (
            SELECT DISTINCT trade_date
            FROM all_stocks_days
            WHERE trade_date &lt;= #{startDate}
            ORDER BY trade_date DESC
            LIMIT 41
        ),
        next_dates AS (
            SELECT DISTINCT trade_date
            FROM all_stocks_days
            WHERE trade_date &gt;= #{startDate}
            ORDER BY trade_date ASC
            LIMIT 41
        ),
        date_range AS (
            SELECT 
                (SELECT MIN(trade_date) FROM prev_dates) AS start_date,
                (SELECT MAX(trade_date) FROM next_dates) AS end_date
        )
        SELECT a.id, a.ts_code, a.trade_date, a.open, a.high, a.low, a.close, a.pct_chg, a.vol, 
               a.amount, a.state,
               COALESCE(NULLIF(a.ma120, 'NaN'), NULL) as ma120, 
               COALESCE(NULLIF(a.ma250, 'NaN'), NULL) as ma250,
               a.name
        FROM all_stocks_days a
        JOIN half_year_stocks h ON a.ts_code = h.ts_code
        JOIN date_range d ON a.trade_date BETWEEN d.start_date AND d.end_date
        ORDER BY a.ts_code, a.trade_date ASC
    </select>

    <!-- 
        查询年线股票数据
        年线定义为收盘价大于250日均线的股票
        1. year_stocks: 筛选收盘价>250日均线的股票
        2. 同样使用前后41个交易日构建日期区间
        3. 返回符合条件的股票在日期区间内的全部交易数据
     -->
    <select id="findYearLine" resultType="com.example.stock.entity.StockData">
        WITH year_stocks AS (
            SELECT DISTINCT a.ts_code
            FROM all_stocks_days a
            <where>
            <if test="tsCode != null">
                    a.ts_code = #{tsCode} AND
            </if>
                a.trade_date = #{startDate}
                AND a.close &gt; COALESCE(NULLIF(a.ma250, 'NaN'), 0)
            </where>
            ORDER BY a.ts_code
            LIMIT #{pageSize} OFFSET #{offset}
        ),
        prev_dates AS (
            SELECT DISTINCT trade_date
            FROM all_stocks_days
            WHERE trade_date &lt;= #{startDate}
            ORDER BY trade_date DESC
            LIMIT 41
        ),
        next_dates AS (
            SELECT DISTINCT trade_date
            FROM all_stocks_days
            WHERE trade_date &gt;= #{startDate}
            ORDER BY trade_date ASC
            LIMIT 41
        ),
        date_range AS (
            SELECT 
                (SELECT MIN(trade_date) FROM prev_dates) AS start_date,
                (SELECT MAX(trade_date) FROM next_dates) AS end_date
        )
        SELECT a.id, a.ts_code, a.trade_date, a.open, a.high, a.low, a.close, a.pct_chg, a.vol, 
               a.amount, a.state,
               COALESCE(NULLIF(a.ma120, 'NaN'), NULL) as ma120, 
               COALESCE(NULLIF(a.ma250, 'NaN'), NULL) as ma250,
               a.name
        FROM all_stocks_days a
        JOIN year_stocks y ON a.ts_code = y.ts_code
        JOIN date_range d ON a.trade_date BETWEEN d.start_date AND d.end_date
        ORDER BY a.ts_code, a.trade_date ASC
    </select>

    <!-- 
        统计符合半年线条件的股票数量
        计算在指定日期收盘价大于120日均线的股票数量
     -->
    <select id="countHalfYearLineStocks" resultType="java.lang.Long">
        SELECT COUNT(DISTINCT a.ts_code)
        FROM all_stocks_days a
        WHERE a.trade_date = #{startDate}
        <if test="tsCode != null">
            AND a.ts_code = #{tsCode}
        </if>
        AND a.close &gt; COALESCE(NULLIF(a.ma120, 'NaN'), 0)
    </select>

    <!-- 
        统计符合年线条件的股票数量
        计算在指定日期收盘价大于250日均线的股票数量
     -->
    <select id="countYearLineStocks" resultType="java.lang.Long">
        SELECT COUNT(DISTINCT a.ts_code)
        FROM all_stocks_days a
        WHERE a.trade_date = #{startDate}
        <if test="tsCode != null">
            AND a.ts_code = #{tsCode}
        </if>
        AND a.close &gt; COALESCE(NULLIF(a.ma250, 'NaN'), 0)
    </select>

    <!-- 
        查询强于大盘的股票数据
        强于大盘定义为股票斜率大于上证指数斜率的股票
        使用all_stocks_days表中的斜率字段，按斜率降序排序
     -->
    <select id="findOutperformData" resultType="com.example.stock.entity.StockData">
        WITH market_slope AS (
            SELECT slope
            FROM shangzheng
            WHERE trade_date = #{startDate}
            LIMIT 1
        ),
        outperform_stocks AS (
            SELECT a.ts_code, a.slope
            FROM all_stocks_days a, market_slope m
            WHERE a.trade_date = #{startDate}
            <if test="tsCode != null">
                AND a.ts_code = #{tsCode}
            </if>
            AND a.slope &gt; m.slope
            ORDER BY a.slope DESC
            LIMIT #{pageSize} OFFSET #{offset}
        ),
        prev_dates AS (
            SELECT DISTINCT trade_date
            FROM all_stocks_days
            WHERE trade_date &lt;= #{startDate}
            ORDER BY trade_date DESC
            LIMIT 41
        ),
        next_dates AS (
            SELECT DISTINCT trade_date
            FROM all_stocks_days
            WHERE trade_date &gt;= #{startDate}
            ORDER BY trade_date ASC
            LIMIT 41
        ),
        date_range AS (
            SELECT 
                (SELECT MIN(trade_date) FROM prev_dates) AS start_date,
                (SELECT MAX(trade_date) FROM next_dates) AS end_date
        )
        SELECT a.id, a.ts_code, a.trade_date, a.open, a.high, a.low, a.close, a.pct_chg, a.vol, 
               a.amount, a.state,
               COALESCE(NULLIF(a.ma120, 'NaN'), NULL) as ma120, 
               COALESCE(NULLIF(a.ma250, 'NaN'), NULL) as ma250,
               a.name
        FROM all_stocks_days a
        JOIN outperform_stocks o ON a.ts_code = o.ts_code
        JOIN date_range d ON a.trade_date BETWEEN d.start_date AND d.end_date
        ORDER BY a.ts_code, a.trade_date ASC
    </select>

    <!-- 
        统计强于大盘的股票数量
        使用主表中的slope字段与上证指数slope比较
     -->
    <select id="countOutperformStocks" resultType="java.lang.Long">
        WITH market_slope AS (
            SELECT slope
            FROM shangzheng
            WHERE trade_date = #{startDate}
            LIMIT 1
        )
        SELECT COUNT(*)
        FROM all_stocks_days a, market_slope m
        WHERE a.trade_date = #{startDate}
        <if test="tsCode != null">
            AND a.ts_code = #{tsCode}
        </if>
        AND a.slope &gt; m.slope
    </select>

    <!-- 
        弱于大盘股票数据查询
        弱于大盘定义为股票斜率小于上证指数斜率的股票
        使用all_stocks_days表中的斜率字段，按斜率升序排序
     -->
    <select id="findUnderperformData" resultType="com.example.stock.entity.StockData">
        WITH market_slope AS (
            SELECT slope
            FROM shangzheng
            WHERE trade_date = #{startDate}
            LIMIT 1
        ),
        underperform_stocks AS (
            SELECT a.ts_code, a.slope
            FROM all_stocks_days a, market_slope m
            WHERE a.trade_date = #{startDate}
            <if test="tsCode != null">
                AND a.ts_code = #{tsCode}
            </if>
            AND a.slope &lt; m.slope
            ORDER BY a.slope ASC
            LIMIT #{pageSize} OFFSET #{offset}
        ),
        prev_dates AS (
            SELECT DISTINCT trade_date
            FROM all_stocks_days
            WHERE trade_date &lt;= #{startDate}
            ORDER BY trade_date DESC
            LIMIT 41
        ),
        next_dates AS (
            SELECT DISTINCT trade_date
            FROM all_stocks_days
            WHERE trade_date &gt;= #{startDate}
            ORDER BY trade_date ASC
            LIMIT 41
        ),
        date_range AS (
            SELECT 
                (SELECT MIN(trade_date) FROM prev_dates) AS start_date,
                (SELECT MAX(trade_date) FROM next_dates) AS end_date
        )
        SELECT a.id, a.ts_code, a.trade_date, a.open, a.high, a.low, a.close, a.pct_chg, a.vol, 
               a.amount, a.state,
               COALESCE(NULLIF(a.ma120, 'NaN'), NULL) as ma120, 
               COALESCE(NULLIF(a.ma250, 'NaN'), NULL) as ma250,
               a.name
        FROM all_stocks_days a
        JOIN underperform_stocks u ON a.ts_code = u.ts_code
        JOIN date_range d ON a.trade_date BETWEEN d.start_date AND d.end_date
        ORDER BY a.ts_code, a.trade_date ASC
    </select>

    <!-- 
        统计弱于大盘的股票数量
        使用主表中的slope字段与上证指数slope比较
     -->
    <select id="countUnderperformStocks" resultType="java.lang.Long">
        WITH market_slope AS (
            SELECT slope
            FROM shangzheng
            WHERE trade_date = #{startDate}
            LIMIT 1
        )
        SELECT COUNT(*)
        FROM all_stocks_days a, market_slope m
        WHERE a.trade_date = #{startDate}
        <if test="tsCode != null">
            AND a.ts_code = #{tsCode}
        </if>
        AND a.slope &lt; m.slope
    </select>

    <!-- 
        查询具有买点的五日调整股票数据
        五日调整是指满足特定技术指标条件的股票
        1. five_day_adjustment_stocks: 筛选state字段等于1的股票（表示有买点）
        2. 同样使用前后41个交易日构建日期区间
        3. 返回符合条件的股票在日期区间内的全部交易数据
        4. 注意state字段在这里作为买点指标保留原始值
     -->
    <select id="findFiveDayAdjustmentStocks" resultType="com.example.stock.entity.StockData">
        WITH five_day_adjustment_stocks AS (
            SELECT DISTINCT a.ts_code
            FROM all_stocks_days a
            <where>
                <if test="tsCode != null and tsCode != ''">
                    a.ts_code = #{tsCode} AND
                </if>
                a.trade_date = #{startDate}
                AND a.state = 1 -- 使用state字段大于0作为买入点判断
            </where>
            ORDER BY a.ts_code
            LIMIT #{pageSize} OFFSET #{offset}
        ),
        prev_dates AS (
            SELECT DISTINCT trade_date
            FROM all_stocks_days
            WHERE trade_date &lt;= #{startDate}
            ORDER BY trade_date DESC
            LIMIT 41
        ),
        next_dates AS (
            SELECT DISTINCT trade_date
            FROM all_stocks_days
            WHERE trade_date &gt;= #{startDate}
            ORDER BY trade_date ASC
            LIMIT 41
        ),
        date_range AS (
            SELECT 
                (SELECT MIN(trade_date) FROM prev_dates) AS start_date,
                (SELECT MAX(trade_date) FROM next_dates) AS end_date
        )
        SELECT a.id, a.ts_code, a.trade_date, a.open, a.high, a.low, a.close, a.pct_chg, a.vol, 
               a.amount, a.state,
               COALESCE(NULLIF(a.ma120, 'NaN'), NULL) as ma120, 
               COALESCE(NULLIF(a.ma250, 'NaN'), NULL) as ma250,
               a.name
        FROM all_stocks_days a
        JOIN five_day_adjustment_stocks ts ON a.ts_code = ts.ts_code
        JOIN date_range d ON a.trade_date BETWEEN d.start_date AND d.end_date
        ORDER BY a.ts_code, a.trade_date ASC
    </select>

    <!-- 
        获取具有买点的五日调整股票代码列表
        返回在指定日期state字段等于1的所有股票代码
        用于前端展示和统计
     -->
    <select id="findFiveDayAdjustmentTsCodes" resultType="java.lang.String">
        SELECT DISTINCT a.ts_code
        FROM all_stocks_days a
        <where>
            a.trade_date = #{startDate}
            <if test="tsCode != null and tsCode != ''">
                AND a.ts_code = #{tsCode}
            </if>
            AND a.state = 1 -- 使用state字段大于0作为买入点判断
        </where>
        ORDER BY a.ts_code
    </select>

    <!-- 
        统计具有买点的五日调整股票数量
        计算在指定日期state字段等于1的股票数量
        用于分页和统计展示
     -->
    <select id="countFiveDayAdjustmentStocks" resultType="java.lang.Long">
        SELECT COUNT(DISTINCT a.ts_code)
        FROM all_stocks_days a
        <where>
            a.trade_date = #{startDate}
            <if test="tsCode != null and tsCode != ''">
                AND a.ts_code = #{tsCode}
            </if>
            AND a.state = 1 -- 使用state字段大于0作为买入点判断
        </where>
    </select>
    <select id="getSingleStockData" resultType="com.example.stock.entity.StockData">
        SELECT 
            id,
            ts_code,
            trade_date,
            open,
            high,
            low,
            close,
            pct_chg,
            vol,
            amount,
            state,
            Fmark,
            COALESCE(NULLIF(ma120, 'NaN'), NULL) as ma120,
            COALESCE(NULLIF(ma250, 'NaN'), NULL) as ma250,
            name
        FROM all_stocks_days
        WHERE ts_code = #{tsCode}
        ORDER BY trade_date ASC
    </select>

    <!-- 
        查询具有MACD金叉信号的股票数据
        MACD金叉是指macd_golden_state字段等于1的股票
        1. macd_golden_stocks: 筛选macd_golden_state字段等于1的股票
        2. 同样使用前后41个交易日构建日期区间
        3. 返回符合条件的股票在日期区间内的全部交易数据
        4. 注意macd_golden_state字段作为信号指标保留原始值
     -->
    <select id="findMacdGoldenCrossStocks" resultType="com.example.stock.entity.StockData">
        WITH macd_golden_stocks AS (
            SELECT DISTINCT a.ts_code
            FROM all_stocks_days a
            <where>
                <if test="tsCode != null and tsCode != ''">
                    a.ts_code = #{tsCode} AND
                </if>
                a.trade_date = #{startDate}
                AND a.macd_golden_state = 1 -- 使用macd_golden_state字段等于1作为信号判断
            </where>
            ORDER BY a.ts_code
            LIMIT #{pageSize} OFFSET #{offset}
        ),
        prev_dates AS (
            SELECT DISTINCT trade_date
            FROM all_stocks_days
            WHERE trade_date &lt;= #{startDate}
            ORDER BY trade_date DESC
            LIMIT 41
        ),
        next_dates AS (
            SELECT DISTINCT trade_date
            FROM all_stocks_days
            WHERE trade_date &gt;= #{startDate}
            ORDER BY trade_date ASC
            LIMIT 41
        ),
        date_range AS (
            SELECT 
                (SELECT MIN(trade_date) FROM prev_dates) AS start_date,
                (SELECT MAX(trade_date) FROM next_dates) AS end_date
        )
        SELECT a.id, a.ts_code, a.trade_date, a.open, a.high, a.low, a.close, a.pct_chg, a.vol, 
               a.amount, a.macd_golden_state,
               COALESCE(NULLIF(a.ma120, 'NaN'), NULL) as ma120, 
               COALESCE(NULLIF(a.ma250, 'NaN'), NULL) as ma250,
               a.name
        FROM all_stocks_days a
        JOIN macd_golden_stocks ts ON a.ts_code = ts.ts_code
        JOIN date_range d ON a.trade_date BETWEEN d.start_date AND d.end_date
        ORDER BY a.ts_code, a.trade_date ASC
    </select>

    <!-- 
        获取具有MACD金叉信号的股票代码列表
        返回在指定日期macd_golden_state字段等于1的所有股票代码
        用于前端展示和统计
     -->
    <select id="findMacdGoldenCrossTsCodes" resultType="java.lang.String">
        SELECT DISTINCT a.ts_code
        FROM all_stocks_days a
        <where>
            a.trade_date = #{startDate}
            <if test="tsCode != null and tsCode != ''">
                AND a.ts_code = #{tsCode}
            </if>
            AND a.macd_golden_state = 1 -- 使用macd_golden_state字段等于1作为信号判断
        </where>
        ORDER BY a.ts_code
    </select>

    <!-- 
        统计具有MACD金叉信号的股票数量
        计算在指定日期macd_golden_state字段等于1的股票数量
        用于分页和统计展示
     -->
    <select id="countMacdGoldenCrossStocks" resultType="java.lang.Long">
        SELECT COUNT(DISTINCT a.ts_code)
        FROM all_stocks_days a
        <where>
            a.trade_date = #{startDate}
            <if test="tsCode != null and tsCode != ''">
                AND a.ts_code = #{tsCode}
            </if>
            AND a.macd_golden_state = 1 -- 使用macd_golden_state字段等于1作为信号判断
        </where>
    </select>
    
    <!-- 
        查询具有KDJ金叉信号的股票数据
        KDJ金叉是指kdj_gloden_state字段等于1的股票
        1. kdj_gloden_stocks: 筛选kdj_gloden_state字段等于1的股票
        2. 同样使用前后41个交易日构建日期区间
        3. 返回符合条件的股票在日期区间内的全部交易数据
        4. 注意kdj_gloden_state字段作为信号指标保留原始值
     -->
    <select id="findKdjGoldenCrossStocks" resultType="com.example.stock.entity.StockData">
        WITH kdj_gloden_stocks AS (
            SELECT DISTINCT a.ts_code
            FROM all_stocks_days a
            <where>
                <if test="tsCode != null and tsCode != ''">
                    a.ts_code = #{tsCode} AND
                </if>
                a.trade_date = #{startDate}
                AND a.kdj_gloden_state = 1 -- 使用kdj_gloden_state字段等于1作为信号判断
            </where>
            ORDER BY a.ts_code
            LIMIT #{pageSize} OFFSET #{offset}
        ),
        prev_dates AS (
            SELECT DISTINCT trade_date
            FROM all_stocks_days
            WHERE trade_date &lt;= #{startDate}
            ORDER BY trade_date DESC
            LIMIT 41
        ),
        next_dates AS (
            SELECT DISTINCT trade_date
            FROM all_stocks_days
            WHERE trade_date &gt;= #{startDate}
            ORDER BY trade_date ASC
            LIMIT 41
        ),
        date_range AS (
            SELECT 
                (SELECT MIN(trade_date) FROM prev_dates) AS start_date,
                (SELECT MAX(trade_date) FROM next_dates) AS end_date
        )
        SELECT a.id, a.ts_code, a.trade_date, a.open, a.high, a.low, a.close, a.pct_chg, a.vol, 
               a.amount, a.kdj_gloden_state,
               COALESCE(NULLIF(a.ma120, 'NaN'), NULL) as ma120, 
               COALESCE(NULLIF(a.ma250, 'NaN'), NULL) as ma250,
               a.name
        FROM all_stocks_days a
        JOIN kdj_gloden_stocks ts ON a.ts_code = ts.ts_code
        JOIN date_range d ON a.trade_date BETWEEN d.start_date AND d.end_date
        ORDER BY a.ts_code, a.trade_date ASC
    </select>

    <!-- 
        获取具有KDJ金叉信号的股票代码列表
        返回在指定日期kdj_gloden_state字段等于1的所有股票代码
        用于前端展示和统计
     -->
    <select id="findKdjGoldenCrossTsCodes" resultType="java.lang.String">
        SELECT DISTINCT a.ts_code
        FROM all_stocks_days a
        <where>
            a.trade_date = #{startDate}
            <if test="tsCode != null and tsCode != ''">
                AND a.ts_code = #{tsCode}
            </if>
            AND a.kdj_gloden_state = 1 -- 使用kdj_gloden_state字段等于1作为信号判断
        </where>
        ORDER BY a.ts_code
    </select>

    <!-- 
        统计具有KDJ金叉信号的股票数量
        计算在指定日期kdj_gloden_state字段等于1的股票数量
        用于分页和统计展示
     -->
    <select id="countKdjGoldenCrossStocks" resultType="java.lang.Long">
        SELECT COUNT(DISTINCT a.ts_code)
        FROM all_stocks_days a
        <where>
            a.trade_date = #{startDate}
            <if test="tsCode != null and tsCode != ''">
                AND a.ts_code = #{tsCode}
            </if>
            AND a.kdj_gloden_state = 1 -- 使用kdj_gloden_state字段等于1作为信号判断
        </where>
    </select>
    
    <!-- 
        查询具有低位资金净流入信号的股票数据
        低位资金净流入是指low_price_state字段等于1的股票
        1. low_price_stocks: 筛选low_price_state字段等于1的股票
        2. 同样使用前后41个交易日构建日期区间
        3. 返回符合条件的股票在日期区间内的全部交易数据
        4. 注意low_price_state字段作为信号指标保留原始值
     -->
    <select id="findLowPriceInflowStocks" resultType="com.example.stock.entity.StockData">
        WITH low_price_stocks AS (
            SELECT DISTINCT a.ts_code
            FROM all_stocks_days a
            <where>
                <if test="tsCode != null and tsCode != ''">
                    a.ts_code = #{tsCode} AND
                </if>
                a.trade_date = #{startDate}
                AND a.low_price_state = 1 -- 使用low_price_state字段等于1作为信号判断
            </where>
            ORDER BY a.ts_code
            LIMIT #{pageSize} OFFSET #{offset}
        ),
        prev_dates AS (
            SELECT DISTINCT trade_date
            FROM all_stocks_days
            WHERE trade_date &lt;= #{startDate}
            ORDER BY trade_date DESC
            LIMIT 41
        ),
        next_dates AS (
            SELECT DISTINCT trade_date
            FROM all_stocks_days
            WHERE trade_date &gt;= #{startDate}
            ORDER BY trade_date ASC
            LIMIT 41
        ),
        date_range AS (
            SELECT 
                (SELECT MIN(trade_date) FROM prev_dates) AS start_date,
                (SELECT MAX(trade_date) FROM next_dates) AS end_date
        )
        SELECT a.id, a.ts_code, a.trade_date, a.open, a.high, a.low, a.close, a.pct_chg, a.vol, 
               a.amount, a.low_price_state,
               COALESCE(NULLIF(a.ma120, 'NaN'), NULL) as ma120, 
               COALESCE(NULLIF(a.ma250, 'NaN'), NULL) as ma250,
               a.name
        FROM all_stocks_days a
        JOIN low_price_stocks ts ON a.ts_code = ts.ts_code
        JOIN date_range d ON a.trade_date BETWEEN d.start_date AND d.end_date
        ORDER BY a.ts_code, a.trade_date ASC
    </select>

    <!-- 
        获取具有低位资金净流入信号的股票代码列表
        返回在指定日期low_price_state字段等于1的所有股票代码
        用于前端展示和统计
     -->
    <select id="findLowPriceInflowTsCodes" resultType="java.lang.String">
        SELECT DISTINCT a.ts_code
        FROM all_stocks_days a
        <where>
            a.trade_date = #{startDate}
            <if test="tsCode != null and tsCode != ''">
                AND a.ts_code = #{tsCode}
            </if>
            AND a.low_price_state = 1 -- 使用low_price_state字段等于1作为信号判断
        </where>
        ORDER BY a.ts_code
    </select>

    <!-- 
        统计具有低位资金净流入信号的股票数量
        计算在指定日期low_price_state字段等于1的股票数量
        用于分页和统计展示
     -->
    <select id="countLowPriceInflowStocks" resultType="java.lang.Long">
        SELECT COUNT(DISTINCT a.ts_code)
        FROM all_stocks_days a
        <where>
            a.trade_date = #{startDate}
            <if test="tsCode != null and tsCode != ''">
                AND a.ts_code = #{tsCode}
            </if>
            AND a.low_price_state = 1 -- 使用low_price_state字段等于1作为信号判断
        </where>
    </select>
    
    <!-- 
        查询具有高位资金净流出信号的股票数据
        高位资金净流出是指high_level_state字段等于1的股票
        1. high_level_stocks: 筛选high_level_state字段等于1的股票
        2. 同样使用前后41个交易日构建日期区间
        3. 返回符合条件的股票在日期区间内的全部交易数据
        4. 注意high_level_state字段作为信号指标保留原始值
     -->
    <select id="findHighLevelOutflowStocks" resultType="com.example.stock.entity.StockData">
        WITH high_level_stocks AS (
            SELECT DISTINCT a.ts_code
            FROM all_stocks_days a
            <where>
                <if test="tsCode != null and tsCode != ''">
                    a.ts_code = #{tsCode} AND
                </if>
                a.trade_date = #{startDate}
                AND a.high_level_state = 1 -- 使用high_level_state字段等于1作为信号判断
            </where>
            ORDER BY a.ts_code
            LIMIT #{pageSize} OFFSET #{offset}
        ),
        prev_dates AS (
            SELECT DISTINCT trade_date
            FROM all_stocks_days
            WHERE trade_date &lt;= #{startDate}
            ORDER BY trade_date DESC
            LIMIT 41
        ),
        next_dates AS (
            SELECT DISTINCT trade_date
            FROM all_stocks_days
            WHERE trade_date &gt;= #{startDate}
            ORDER BY trade_date ASC
            LIMIT 41
        ),
        date_range AS (
            SELECT 
                (SELECT MIN(trade_date) FROM prev_dates) AS start_date,
                (SELECT MAX(trade_date) FROM next_dates) AS end_date
        )
        SELECT a.id, a.ts_code, a.trade_date, a.open, a.high, a.low, a.close, a.pct_chg, a.vol, 
               a.amount, a.high_level_state,
               COALESCE(NULLIF(a.ma120, 'NaN'), NULL) as ma120, 
               COALESCE(NULLIF(a.ma250, 'NaN'), NULL) as ma250,
               a.name
        FROM all_stocks_days a
        JOIN high_level_stocks ts ON a.ts_code = ts.ts_code
        JOIN date_range d ON a.trade_date BETWEEN d.start_date AND d.end_date
        ORDER BY a.ts_code, a.trade_date ASC
    </select>

    <!-- 
        获取具有高位资金净流出信号的股票代码列表
        返回在指定日期high_level_state字段等于1的所有股票代码
        用于前端展示和统计
     -->
    <select id="findHighLevelOutflowTsCodes" resultType="java.lang.String">
        SELECT DISTINCT a.ts_code
        FROM all_stocks_days a
        <where>
            a.trade_date = #{startDate}
            <if test="tsCode != null and tsCode != ''">
                AND a.ts_code = #{tsCode}
            </if>
            AND a.high_level_state = 1 -- 使用high_level_state字段等于1作为信号判断
        </where>
        ORDER BY a.ts_code
    </select>

    <!-- 
        统计具有高位资金净流出信号的股票数量
        计算在指定日期high_level_state字段等于1的股票数量
        用于分页和统计展示
     -->
    <select id="countHighLevelOutflowStocks" resultType="java.lang.Long">
        SELECT COUNT(DISTINCT a.ts_code)
        FROM all_stocks_days a
        <where>
            a.trade_date = #{startDate}
            <if test="tsCode != null and tsCode != ''">
                AND a.ts_code = #{tsCode}
            </if>
            AND a.high_level_state = 1 -- 使用high_level_state字段等于1作为信号判断
        </where>
    </select>

    <!-- 
        查询指定股票在指定日期的斜率
        直接从数据库中获取预先计算好的斜率值
     -->
    <select id="findStockSlope" resultType="java.lang.Double">
        SELECT slope
        FROM all_stocks_days
        WHERE ts_code = #{tsCode}
        AND trade_date = #{tradeDate}
        LIMIT 1
    </select>

    <!-- 
        查询指定日期的市场斜率
        从shangzheng表中获取特定日期的上证指数斜率
        用于衡量整体市场趋势，与个股斜率比较可判断强弱
     -->
    <select id="findMarketSlope" resultType="java.lang.Double">
        SELECT slope
        FROM shangzheng
        WHERE trade_date = #{tradeDate}
        LIMIT 1
    </select>
</mapper> 